## Test Generator for HW02/HW03
This is the test generator that we have created for HW02 and HW03.

Please find the following files along with this README in this folder:
* `testgen.c` - this is the main file for generating the test case. Please read below regarding the flow for testgen file
* `makefile` - this is the makefile to generate the binary for the tesgen


Flow of Testgen
================

You can also see the code and the comments inside the code in `testgen.c` file. The file `testgen.c` have lots of comments to help you understand the code

General flow of the testgen file is as follows:

1. It first generates the means is in some range, where range is given as an input, let's say if input is 100, then range is between [-100,100]
2. The number of means you want for mean-shift algorithm is also an input
3. Dimension is also taken as input
4. Number of points to generate is also taken as input
5. The code then splits the range into `k` means eg. for 3 means evenly distrubed in the range [-100,100] will be ((-50.0, -50.0), (0.0, 0.0) , (50, 50))
6. It then generates random points around those means. To do this it follows the following procedure:
	* First generates a random number between 0 & 1
	* It then subtracts 0.5 from the above number, thus the range of the random number will now be between [-0.5, 0.5]
	* It multiply this random number with range/(k + 1) eg. in above case it will be 100 /(3 + 1)
	* The code then randomly chooses the means and add the above number to that means eg. (-50.0 + random * range/(k + 1), -50.0 + random * range/(k + 1))
  * It generates as many number of points as given as the input


Running TestGenerator
=====================
The test generator can be compiled by running simple `make` command. 
The `make` command also generates 5 test cases, which we gave it to you for the testing HW02. 

Once the binary `testgen` is generated, you can execute the binary `testgen` in the following way:

```
./testgen 1001 6 2000 2 500 > test1.txt
```
1. `1001` - this is the seed for random generator function. You can use any seed. If you use -1, it will take present time as random seed and the test case will change. We are using some number because we can generate the same test case with this seed. If you use -1 as seed, you will not be able to generate the same test case again.
2. `6` - this is the number of means or `K`, that you need to generate data for. Please use the same value of `K` when testing your code. Your value should be >=2
3. `2000` - this is number of data points that you want to generate.
4. `2` - it is the dimension of the data point. The value of this should be >=2.
5. `500` - this is the range between which the data points will get generated i.e. your data points will be between [-range, range]. Please provide only the positive value.
6. `>` - this symbol is to redirect your output of the testgen to a file
7. `test1.txt` - this file will have the data points generated by the binary.


Caution
===========
A word of caution, according to the testgen algorithm for generating testcases, we are first finalizing means 
and then placing the random points around those means. 
So you might be inclined to believe that the answer of the mean-shift algorithm that you run must be those means. 


This is not always true. Because the points in the test cases are generated in a random fashion and also iterative mean-shift algorithm will generate different results.


For eg. lets suppose we choose 2 means `6` and `9` , we then placed points around them - lets says `5,7,8,10`. We are considering only 1 dimension
points here to make it easy to understand. Now, you think that if you get points `5,7,8,10` as input to your mean-shift algorithm, it should give you
`6` and `9`. This may or may not happen. 

### Running mean-shift algorithm for above example
1. Iteration 1: In the First iteration of the algorithm, random means are choosen, let's say in this case it happened to be `7` and `15`. The algorithm checks which means is closest to each data point, in our case we can see that `7` is closer to all of them as compared to 15. So, in 1st iteration means 
`7` will be updated to mean of all the points, which is = `(5+7+8+10)/4` = `7.5`. 

2. Iteration 2: According to the algorithm,
in next iteration the means will be `7.5` and `15` (you can put this to 0 also or keep this). Now, in this iteration `7.5` is closer to all of 
them and thus, there will not be any change in the means and the algorithm will stop. So your output will be `7.5` and `15` (or `0`) which is not what we expected.
